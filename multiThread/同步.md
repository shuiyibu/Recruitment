`竞争条件(race condition)`

# 锁对象


## `synchronized`

## `ReentrantLock`
```
myLock.lock();
try
{
  critical section
}
finally
{
  myLock.unlock();
}
```

>如果使用锁，就不能使用带资源的try语句
```
class Bank
{
  private Lock bankLock = new ReentrantLock();
  public void transfer(int from, int to, double amount)
	{
		bankLock.lock();
		try
		{
			if (accounts[from] < amount)
				return;

			System.err.println(Thread.currentThread());
			accounts[from] -= amount;
			System.out.printf(" %10.2f from %d to %d", amount, from, to);
			accounts[to] += amount;
			System.out.printf("Total Balance: %10.2f%n", getTotalBalance());

		}
		finally
		{
			bankLock.unlock();
		}
	}
}
```
>每一个Bank对象有自己的ReentrantLock对象，如果两个线程试图访问同一个 Bank 对象，那么锁以串行方式提供服务。但是，如果**两个线程访问不同的Bank对象，每个线程得到不同的锁对象，两个线程都不会发生阻塞**。


>锁是`可重入`的

# 条件对象/条件变量（conditional Variable）
